---
title: "Programming Exercises"
author: "Gustavo Arruda Franco"
output: github_document
---

## Load necessary libraries

```{r}
library(tidyverse)
library(knitr)
```

## Compute the number of unique values in each column of `iris`

### Using a `for` loop

```{r}

uniq_for <- function(a) {
  uniq_out <- array(dim = ncol(a))
  len_out <- vector("integer", length = ncol(a))
  for (i in seq_along(a)){
    uniq_out[i] <- unique(a[i])
    print(uniq_out)
    len_out[i] <- length(uniq_out[i])
  }
  return(len_out)
}

uniq_for(iris)

```

### Using a `map` function

```{r}

#Generalized the task into a function.

uniq_map <- function(a) {
  uniq_val <- map(a, unique) #First, it creates a dataframe just with the unique values in each column
  count_uniq <- map_int(uniq_val, length) #Second, it creates a vector with the length of each column
  return(kable(count_uniq, col.names = "Unique Values", caption = "Count of Unique Values per Column")) #At last, it makes the visualization prettier with a decent table explaining values
}

uniq_map(iris) #Then, I just needed to call the specified dataframe "Iris" into function

```

## Calculate the square of each element in vector `x`

```{r}
x <- seq(from = 30, to = 1)
x
```

### Using a `for` loop

```{r}

#Generalized this task on a function as well.

sqr_for <- function(a){
  output <- vector("integer", length(a)) #Assigned the size of the output for efficiency
  for (i in seq_along(a)){
    output[i] <- a[i] ^ 2 #Substitutes each item in the blank output for squared of homologous item within input vector
  }
  vis_result <- data.frame(a, output) #Creates dataframe comparing output and input side to side
  return(kable(vis_result, col.names = c("x", "x^2"))) #Makes visualization of this function easier through a table
}

sqr_for(x) #Called specified vector into function

```

### Using a `map` function

```{r}
sqr_function <- function(a){ #To make the map method work I need a pre-defined squaring function
  squared <- a ^ 2
}
sqr_map <- function(a){ #This function takes the previous one and applies it to a whole vector, creating a table for easy visualization in the end
  squared_vector <- map_dbl(a, sqr_function)
  sqr_vis <- data.frame(a, squared_vector)
  return(kable(sqr_vis, col.names = c("x", "x^2")))
}

sqr_map(x)

```

## Write a function to calculate length of sides in a right-triangle using the Pythagorean Theorem

```{r}

pyth_thm <- function(a = NA, b = NA, c = NA){ #The three arguments are set to NA by default
  enough_cond <- is.na(a) + is.na(b) + is.na(c) #If any of the arguments is NA, they will add 1 to this count
  numeric_cond <- is.numeric(a) + is.numeric(b) + is.numeric(c) #If any of the arguments is numerical, they will add 1 to this count
  if (enough_cond == 2 | enough_cond == 0){ #If only one argument is passed to the function, then the NA count equals to 2; conversely, if three arguments are passed, the NA count equals to 0. In that case the function stops, hence the "enough" variable name.
    stop()
  }
  else {
    if (numeric_cond != 2){ #Given that the previous "if" statement limits this function to only two arguments, this particular "if" statement guarantees that it is necessary that the two arguments passed into this function are numerical.
      stop()
    }
    else{ #This conditionals within the function detects which of the three arguments is blank. Then they proceed to apply the Pythagorean formula to the remaining arguments and print the answer.
     if (is.na(c)){
       print(paste("C =", as.character(sqrt(a^2 + b^2))))
     }
     if (is.na(b)){
       print(paste("B =", as.character(sqrt(c^2 - a^2))))
     }
     if (is.na(a)){
       print(paste("B =", as.character(sqrt(c^2 - b^2))))
     }
    }
  }
}

```

## Session info

```{r}
devtools::session_info()
```


