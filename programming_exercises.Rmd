---
title: "Programming Exercises"
author: "Gustavo Arruda Franco"
output: github_document
---

## Load necessary libraries

```{r}
library(tidyverse)
library(knitr)
```

## Compute the number of unique values in each column of `iris`

### Using a `for` loop

```{r}

uniq_for <- function(a) {
  uniq_out <- array(dim = ncol(a))
  len_out <- vector("integer", length = ncol(a))
  for (i in seq_along(a)){
    uniq_out[i] <- unique(a[i])
    print(uniq_out)
    len_out[i] <- length(uniq_out[i])
  }
  return(len_out)
}

uniq_for(iris)

```

### Using a `map` function

```{r}

#Generalized the task into a function.

uniq_map <- function(a) {
  uniq_val <- map(a, unique) #First, it creates a dataframe just with the unique values in each column
  count_uniq <- map_int(uniq_val, length) #Second, it creates a vector with the length of each column
  return(kable(count_uniq, col.names = "Unique Values", caption = "Count of Unique Values per Column")) #At last, it makes the visualization prettier with a decent table explaining values
}

uniq_map(iris) #Then, I just needed to call the specified dataframe "Iris" into function

```

## Calculate the square of each element in vector `x`

```{r}
x <- seq(from = 30, to = 1)
x
```

### Using a `for` loop

```{r}

#Generalized this task on a function as well.

sqr_for <- function(a){
  output <- vector("integer", length(a)) #Assigned the size of the output for efficiency
  for (i in seq_along(a)){
    output[i] <- a[i] ^ 2 #Substitutes each item in the blank output for squared of homologous item within input vector
  }
  vis_result <- data.frame(a, output) #Creates dataframe comparing output and input side to side
  return(kable(vis_result, col.names = c("x", "x^2"))) #Makes visualization of this function easier through a table
}

sqr_for(x) #Called specified vector into function

```

### Using a `map` function

```{r}
sqr_function <- function(a){ #To make the map method work I need a pre-defined squaring function
  squared <- a ^ 2
}
sqr_map <- function(a){ #This function takes the previous one and applies it to a whole vector, creating a table for easy visualization in the end
  squared_vector <- map_dbl(a, sqr_function)
  sqr_vis <- data.frame(a, squared_vector)
  return(kable(sqr_vis, col.names = c("x", "x^2")))
}

sqr_map(x)

```

## Write a function to calculate length of sides in a right-triangle using the Pythagorean Theorem

```{r}

```

## Session info

```{r}
devtools::session_info()
```


